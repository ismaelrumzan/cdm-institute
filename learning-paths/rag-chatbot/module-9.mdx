---
title: "Semantic Search and Retrieval"
description: "Implement efficient semantic search algorithms and optimization. Handle query processing and result filtering for scalable retrieval systems."
---

## Learning Objectives

By the end of this module, you will be able to:

- Implement efficient semantic search algorithms
- Optimize similarity calculations and ranking
- Handle query processing and result filtering
- Design scalable retrieval systems

## Module Overview

This module focuses on implementing the core semantic search functionality for your RAG agent. You'll build efficient search algorithms, optimize performance, and ensure your retrieval system scales effectively.

<Callout>
  **Time Estimate**: 90 minutes (40 + 30 + 20 minutes for each section)
</Callout>

---

## 9.1 Semantic Search Implementation

**Duration**: 40 minutes

### Understanding Semantic Search

Semantic search finds content based on meaning rather than exact keyword matches:

<Callout type="info">
  **Semantic Search** converts queries and documents into vectors, then finds
  the most similar vectors using similarity metrics like cosine similarity.
</Callout>

### Creating the Search Function

Implement the core search functionality:

<CodeGroup>
  <CodeGroupItem title="Actual Implementation from Repository">
```typescript
// lib/ai/search.ts
import { embed } from "ai";
import { openai } from "@ai-sdk/openai";
import { db } from "@/lib/db";
import { embeddings } from "@/lib/db/schema/embeddings";
import { sql } from "drizzle-orm";

const embeddingModel = openai.embedding("text-embedding-ada-002");

export async function findRelevantContent(
  query: string,
  limit: number = 5,
  similarityThreshold: number = 0.7
) {
  try {
    // Generate embedding for the query
    const { embedding: queryEmbedding } = await embed({
      model: embeddingModel,
      value: query,
    });

    // Search for similar embeddings in the database
    const results = await db
      .select({
        id: embeddings.id,
        content: embeddings.content,
        similarity: sql<number>`
          1 - (${queryEmbedding} <=> ${embeddings.embedding})
        `.as("similarity"),
      })
      .from(embeddings)
      .where(
        sql`1 - (${queryEmbedding} <=> ${embeddings.embedding}) > ${similarityThreshold}`
      )
      .orderBy(sql`similarity DESC`)
      .limit(limit);

    return results.map((result) => ({
      id: result.id,
      content: result.content,
      similarity: result.similarity,
    }));

} catch (error) {
console.error("Search error:", error);
throw new Error("Failed to search knowledge base");
}
}

````
  </CodeGroupItem>
</CodeGroup>

### Understanding the Search Process

<Steps>
  <Step title="1. Query Embedding">
    Convert the user's query into a vector representation
  </Step>
  <Step title="2. Similarity Calculation">
    Calculate similarity between query and stored embeddings
  </Step>
  <Step title="3. Filtering">
    Filter results based on similarity threshold
  </Step>
  <Step title="4. Ranking">
    Sort results by similarity score
  </Step>
  <Step title="5. Limiting">
    Return top N most relevant results
  </Step>
</Steps>

### Similarity Metrics

Understand different similarity calculations:

<Columns cols={2}>
  <Card title="Cosine Similarity" icon="math">
    **Formula**: cos(θ) = (A·B) / (||A|| × ||B||)
    **Range**: -1 to 1 (1 = identical)
    **Use Case**: Most common for text embeddings
  </Card>
  <Card title="Euclidean Distance" icon="ruler">
    **Formula**: √(Σ(Ai - Bi)²)
    **Range**: 0 to ∞ (0 = identical)
    **Use Case**: Less common for embeddings
  </Card>
</Columns>

### Advanced Search Features

Add more sophisticated search capabilities:

<CodeGroup>
  <CodeGroupItem title="Advanced Search">
    ```tsx
    export async function advancedSearch({
      query,
      limit = 5,
      similarityThreshold = 0.7,
      includeMetadata = false,
      filterByResource = null,
    }: {
      query: string;
      limit?: number;
      similarityThreshold?: number;
      includeMetadata?: boolean;
      filterByResource?: string | null;
    }) {
      try {
        const { embedding: queryEmbedding } = await embed({
          model: embeddingModel,
          value: query,
        });

        let queryBuilder = db
          .select({
            id: embeddings.id,
            content: embeddings.content,
            resourceId: embeddings.resourceId,
            similarity: sql<number>`
              1 - (${queryEmbedding} <=> ${embeddings.embedding})
            `.as("similarity"),
          })
          .from(embeddings)
          .where(
            sql`1 - (${queryEmbedding} <=> ${embeddings.embedding}) > ${similarityThreshold}`
          );

        // Add resource filtering if specified
        if (filterByResource) {
          queryBuilder = queryBuilder.where(eq(embeddings.resourceId, filterByResource));
        }

        const results = await queryBuilder
          .orderBy(sql`similarity DESC`)
          .limit(limit);

        return results.map((result) => ({
          id: result.id,
          content: result.content,
          resourceId: result.resourceId,
          similarity: result.similarity,
        }));
      } catch (error) {
        console.error("Advanced search error:", error);
        throw new Error("Failed to perform advanced search");
      }
    }
    ```
  </CodeGroupItem>
</CodeGroup>

---

## 9.2 Search Optimization and Performance

**Duration**: 30 minutes

### Index Optimization

Optimize your vector index for better performance:

<Callout type="info">
  **HNSW Index**: Hierarchical Navigable Small World index provides fast approximate search for high-dimensional vectors.
</Callout>

<CodeGroup>
  <CodeGroupItem title="Index Configuration">
    ```sql
    -- Create optimized HNSW index
    CREATE INDEX ON embeddings
    USING hnsw (embedding vector_cosine_ops)
    WITH (m = 16, ef_construction = 64);

    -- Parameters explanation:
    -- m: Maximum number of connections per layer (default: 16)
    -- ef_construction: Size of dynamic candidate list during construction (default: 64)
    ```
  </CodeGroupItem>
</CodeGroup>

### Query Optimization

Optimize your database queries:

<CodeGroup>
  <CodeGroupItem title="Optimized Query">
    ```tsx
    export async function optimizedSearch(
      query: string,
      limit: number = 5
    ) {
      const { embedding: queryEmbedding } = await embed({
        model: embeddingModel,
        value: query,
      });

      // Use prepared statement for better performance
      const results = await db.execute(sql`
        SELECT
          id,
          content,
          1 - (${queryEmbedding} <=> embedding) as similarity
        FROM embeddings
        WHERE 1 - (${queryEmbedding} <=> embedding) > 0.7
        ORDER BY similarity DESC
        LIMIT ${limit}
      `);

      return results;
    }
    ```
  </CodeGroupItem>
</CodeGroup>

### Caching Strategies

Implement caching to improve performance:

<CodeGroup>
  <CodeGroupItem title="Search Caching">
    ```tsx
    import { LRUCache } from "lru-cache";

    // Cache for query embeddings
    const embeddingCache = new LRUCache<string, number[]>({
      max: 1000, // Maximum number of cached embeddings
      ttl: 1000 * 60 * 60, // 1 hour TTL
    });

    // Cache for search results
    const searchCache = new LRUCache<string, any[]>({
      max: 500, // Maximum number of cached results
      ttl: 1000 * 60 * 5, // 5 minutes TTL
    });

    export async function cachedSearch(
      query: string,
      limit: number = 5
    ) {
      // Check cache first
      const cacheKey = `${query}:${limit}`;
      const cachedResults = searchCache.get(cacheKey);
      if (cachedResults) {
        return cachedResults;
      }

      // Perform search
      const results = await findRelevantContent(query, limit);

      // Cache results
      searchCache.set(cacheKey, results);

      return results;
    }
    ```
  </CodeGroupItem>
</CodeGroup>

### Performance Monitoring

Add performance monitoring to track search performance:

<CodeGroup>
  <CodeGroupItem title="Performance Monitoring">
    ```tsx
    export async function monitoredSearch(
      query: string,
      limit: number = 5
    ) {
      const startTime = Date.now();

      try {
        const results = await findRelevantContent(query, limit);
        const duration = Date.now() - startTime;

        // Log performance metrics
        console.log(`Search completed in ${duration}ms for query: "${query}"`);

        // Track metrics (you could send to a monitoring service)
        trackSearchMetrics({
          query,
          duration,
          resultCount: results.length,
          timestamp: new Date().toISOString(),
        });

        return results;
      } catch (error) {
        const duration = Date.now() - startTime;
        console.error(`Search failed after ${duration}ms:`, error);
        throw error;
      }
    }

    function trackSearchMetrics(metrics: {
      query: string;
      duration: number;
      resultCount: number;
      timestamp: string;
    }) {
      // Send to monitoring service (e.g., DataDog, New Relic, etc.)
      // This is a placeholder for actual monitoring implementation
    }
    ```
  </CodeGroupItem>
</CodeGroup>

---

## 9.3 Testing and Validation

**Duration**: 20 minutes

### Search Testing

Create comprehensive tests for your search functionality:

<CodeGroup>
  <CodeGroupItem title="Search Tests">
    ```tsx
    export async function testSearchFunctionality() {
      const testCases = [
        {
          query: "machine learning",
          expectedKeywords: ["machine learning", "ML", "artificial intelligence"],
          description: "Basic semantic search",
        },
        {
          query: "neural networks",
          expectedKeywords: ["neural", "network", "deep learning"],
          description: "Related concept search",
        },
        {
          query: "programming languages",
          expectedKeywords: ["programming", "code", "software"],
          description: "Broad concept search",
        },
      ];

      for (const testCase of testCases) {
        console.log(`Testing: ${testCase.description}`);

        try {
          const results = await findRelevantContent(testCase.query, 3);

          console.log(`Query: "${testCase.query}"`);
          console.log(`Results: ${results.length}`);

          for (const result of results) {
            console.log(`- Similarity: ${result.similarity.toFixed(3)} | Content: ${result.content.substring(0, 100)}...`);
          }

          // Validate results
          const hasRelevantContent = results.some(result =>
            testCase.expectedKeywords.some(keyword =>
              result.content.toLowerCase().includes(keyword.toLowerCase())
            )
          );

          console.log(`Relevant content found: ${hasRelevantContent ? 'YES' : 'NO'}`);
        } catch (error) {
          console.error(`Test failed: ${error}`);
        }

        console.log("---");
      }
    }
    ```
  </CodeGroupItem>
</CodeGroup>

### Performance Testing

Test search performance with different scenarios:

<CodeGroup>
  <CodeGroupItem title="Performance Tests">
    ```tsx
    export async function testSearchPerformance() {
      const queries = [
        "machine learning",
        "artificial intelligence",
        "deep learning",
        "neural networks",
        "programming",
        "database",
        "web development",
        "mobile apps",
      ];

      const results = [];

      for (const query of queries) {
        const startTime = Date.now();

        try {
          const searchResults = await findRelevantContent(query, 5);
          const duration = Date.now() - startTime;

          results.push({
            query,
            duration,
            resultCount: searchResults.length,
            success: true,
          });
        } catch (error) {
          const duration = Date.now() - startTime;
          results.push({
            query,
            duration,
            resultCount: 0,
            success: false,
            error: error instanceof Error ? error.message : "Unknown error",
          });
        }
      }

      // Analyze results
      const successfulResults = results.filter(r => r.success);
      const avgDuration = successfulResults.reduce((sum, r) => sum + r.duration, 0) / successfulResults.length;
      const maxDuration = Math.max(...successfulResults.map(r => r.duration));
      const minDuration = Math.min(...successfulResults.map(r => r.duration));

      console.log("Performance Test Results:");
      console.log(`Average duration: ${avgDuration.toFixed(2)}ms`);
      console.log(`Max duration: ${maxDuration}ms`);
      console.log(`Min duration: ${minDuration}ms`);
      console.log(`Success rate: ${successfulResults.length}/${results.length}`);

      return results;
    }
    ```
  </CodeGroupItem>
</CodeGroup>

### Edge Case Testing

Test edge cases and error conditions:

<CodeGroup>
  <CodeGroupItem title="Edge Case Tests">
    ```tsx
    export async function testEdgeCases() {
      const edgeCases = [
        {
          name: "Empty query",
          query: "",
          shouldThrow: true,
        },
        {
          name: "Very long query",
          query: "a".repeat(1000),
          shouldThrow: false,
        },
        {
          name: "Special characters",
          query: "What is @#$%^&*()?",
          shouldThrow: false,
        },
        {
          name: "Non-English query",
          query: "¿Qué es el aprendizaje automático?",
          shouldThrow: false,
        },
      ];

      for (const testCase of edgeCases) {
        console.log(`Testing edge case: ${testCase.name}`);

        try {
          const results = await findRelevantContent(testCase.query, 3);

          if (testCase.shouldThrow) {
            console.log("❌ Expected error but got results");
          } else {
            console.log(`✅ Success: ${results.length} results`);
          }
        } catch (error) {
          if (testCase.shouldThrow) {
            console.log("✅ Expected error occurred");
          } else {
            console.log(`❌ Unexpected error: ${error}`);
          }
        }
      }
    }
    ```
  </CodeGroupItem>
</CodeGroup>

### Search Quality Evaluation

Evaluate the quality of your search results:

<CodeGroup>
  <CodeGroupItem title="Quality Evaluation">
    ```tsx
    export async function evaluateSearchQuality() {
      const evaluationQueries = [
        {
          query: "machine learning",
          expectedRelevance: ["machine learning", "ML", "artificial intelligence"],
          description: "Direct concept match",
        },
        {
          query: "how to build a website",
          expectedRelevance: ["web", "website", "development", "HTML", "CSS"],
          description: "How-to question",
        },
        {
          query: "best programming languages",
          expectedRelevance: ["programming", "language", "Python", "JavaScript", "Java"],
          description: "Comparison question",
        },
      ];

      let totalRelevance = 0;
      let totalQueries = 0;

      for (const evalQuery of evaluationQueries) {
        const results = await findRelevantContent(evalQuery.query, 5);

        let relevantResults = 0;
        for (const result of results) {
          const isRelevant = evalQuery.expectedRelevance.some(keyword =>
            result.content.toLowerCase().includes(keyword.toLowerCase())
          );
          if (isRelevant) relevantResults++;
        }

        const relevanceScore = relevantResults / results.length;
        totalRelevance += relevanceScore;
        totalQueries++;

        console.log(`${evalQuery.description}: ${(relevanceScore * 100).toFixed(1)}% relevant`);
      }

      const averageRelevance = totalRelevance / totalQueries;
      console.log(`Overall relevance: ${(averageRelevance * 100).toFixed(1)}%`);

      return averageRelevance;
    }
    ```
  </CodeGroupItem>
</CodeGroup>

### Practical Exercise

<Callout type="info">
  **Exercise**: Test and optimize your semantic search
</Callout>

<Steps>
  <Step title="1. Basic Search Testing">
    Test basic search functionality with different queries
  </Step>
  <Step title="2. Performance Testing">
    Measure search performance and identify bottlenecks
  </Step>
  <Step title="3. Quality Evaluation">
    Evaluate search result relevance and accuracy
  </Step>
  <Step title="4. Optimization">
    Implement caching and other optimizations
  </Step>
</Steps>

### Reflection Questions

<Callout type="warning">
  Take a moment to reflect on these questions:
</Callout>

1. **How would you implement search result caching?**
   - Consider cache invalidation and memory usage

2. **What strategies would you use for search relevance feedback?**
   - Think about user feedback and result ranking

3. **How would you scale search for millions of documents?**
   - Consider sharding, partitioning, and distributed search

### Next Steps

<Callout type="info">
  **Ready to continue?** In the next module, you'll deploy your RAG agent to production and optimize for performance.
</Callout>

---

## Module Summary

In this module, you successfully:

- **Search Implementation**: Built efficient semantic search algorithms
- **Performance Optimization**: Optimized queries and added caching
- **Testing and Validation**: Created comprehensive tests for search functionality
- **Quality Evaluation**: Implemented search quality assessment

### Key Takeaways

- Semantic search finds content based on meaning, not just keywords
- Proper indexing is crucial for search performance
- Caching can significantly improve search response times
- Comprehensive testing ensures search quality and reliability

### Resources

- [pgvector Documentation](https://github.com/pgvector/pgvector) - Vector similarity search
- [PostgreSQL Indexing](https://www.postgresql.org/docs/current/indexes.html) - Database indexing guide
- [Vector Similarity Search](https://platform.openai.com/docs/guides/embeddings) - OpenAI embeddings guide
- [Search Quality Metrics](https://en.wikipedia.org/wiki/Information_retrieval) - Information retrieval concepts

### Troubleshooting

If you encounter issues:

1. **Slow Search**: Check index configuration and query optimization
2. **Poor Results**: Adjust similarity threshold and embedding quality
3. **Memory Issues**: Implement caching and result limiting
4. **Index Problems**: Verify pgvector extension and index creation

<Callout type="success">
  **Module Complete!** Your semantic search is working efficiently. Continue to [Module 10: Production Deployment and Optimization](/learning-paths/rag-chatbot/module-10) to deploy your RAG agent to production.
</Callout>
````
